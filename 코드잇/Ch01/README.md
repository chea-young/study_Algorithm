## 좋은 알고리즘이란 무엇인가?
- 한 문제에 대해서는 어떻게 그 문제를 해결하는가에 다양하게 해결하는 방법이 존재한다. 그렇기 때문에 알고리즘은 중요하다.

### 탐색하기
- 탐색: 저장된 정보들 중에서 원하는 값을 찾는 것
#### 선형탐색 알고리즘(linear search algorithm)
- 왼쪽부터 차례대로 살펴보는 것

#### 이진탐색 알고리즘(binary search algorithm)
- 중간 값에서 크고 작음을 확인해서 찾아가는 것.
- 크면 오른쪽, 작으면 왼쪽을 살펴봄.

--> 리스트가 더 길어지는 것을 생각해 보았을 떄 '이진 탐색'이 선형탐색보다 더 빠르다. 

### 정렬하기
- 리스트의 원소들을 특정 순서로 정리하는 것
- python에 sorted나 .sort() method가 있지만 이것은 기초 알고리즘 떄문에 이것을 배움으로써 문제 해결의 기초를 배울 수 있음.
- 이미 거의 정렬된 리스트를 정렬할 때는 삽입 정렬(Insertion Sort)이 가장 빠른 반면, 무작위 순서의 리스트를 정렬할 때는 힙 정렬(Heapsort)이 가장 먼저 끝남
- 아예 정반대로 정렬된 리스트의 경우에는 삽입 정렬이 매우 오래 걸림
- 선택 정렬(Selection Sort)과 합병 정렬(Merge Sort)은 상황에 영향을 받지 않고 일정한 시간이 소요

#### 선택정렬(Selection Sort)
- 각 위치에 어떤 값이 들어갈 지 찾음.
- 순서대로 다 확인해보면서 가장 작은 수를 찾아 하나씩 그것으로 교체하는 것

#### 삽입정렬(Insertion Sort)
- 각 값이 어떤 위치에 들어갈 지 찾음.
- 순서대로 2개씩 확인해보면서 작으면 교체하는 과정을 반복하는 것

#### 이외의 정렬 알고리즘
- BUbble 알고리즘
- Shell 알고리즘
- Merge 알고리즘
- Heap 알고리즘
- Quick 알고리즘
- Quick3 알고리즘

#### 알고리즘 평가법
- 우리에게 주어진 시간은 한정적이기 때문에 시간과 공간이 중요
- 문제를 빨리 해결하는 알고리즘이 중요 --> 시간 복잡도

#### 시간복잡도 (Time Complexity)
- 데이터가 많아질수록 걸리는 시간이 얼마나 급격히 변화하는 것 
- 오래걸리면 시간 복잡도가 크다
#### 점근 표기법 (Big-O N)
- 시간 복잡도와 공간복잡도로 모두 표현 가능
- 알고리즘 크기를 Input의 크기로 측정하는 것
- n이 엄청 크다고 가정
    - n이 별로 크지 않은 경우, 안 좋은 알고리즘을 써도 문제가 되지 않기 때문
<시간복잡도 기준>
- 선형탐색: O(1) + O(1) + O(1)/O(n) + O(1) = O(1)/ O(n)
- 이진탐색: O(1) + O(1) + O(1)/O(lg n) + O(1) = O(1)/ O(lg n)
- 리스트 크기와 관련 있으면 O(n)
- 반복되는 범위가 계속 반으로 줄어들면 O(lg n)

#### 공간복잡도(Space Complexity)
- Input 크기에 비례해서 알고리즘이 사용되는 메모리 공간
- 이것 또한 Big -O로 표기 가능